<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법 | Kyungwook&#39;s Devlog</title>
<meta name="keywords" content="OpenClaw, Automation, Heartbeat, AI Agent, 생산성">
<meta name="description" content="OpenClaw를 사용하다 보면 &ldquo;AI가 좀 더 능동적으로 움직였으면 좋겠다&quot;는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?
바로 이것이 하트비트(Heartbeat) 기능이 해결하는 문제입니다.
하트비트란 무엇인가?
하트비트는 OpenClaw 에이전트가 일정 주기로 받는 &ldquo;펄스(pulse)&ldquo;입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 &ldquo;지금 내가 해야 할 일이 있나?&ldquo;를 스스로 판단합니다.
기본 하트비트 프롬프트는 다음과 같습니다:
Read HEARTBEAT.md if it exists (workspace context). 
Follow it strictly. Do not infer or repeat old tasks from prior chats. 
If nothing needs attention, reply HEARTBEAT_OK.
하트비트 vs Cron: 언제 무엇을 쓸까?
OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?">
<meta name="author" content="">
<link rel="canonical" href="https://kwbaek.github.io/posts/2026-02-23-openclaw-heartbeat-automation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kwbaek.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kwbaek.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kwbaek.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kwbaek.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kwbaek.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://kwbaek.github.io/posts/2026-02-23-openclaw-heartbeat-automation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://kwbaek.github.io/posts/2026-02-23-openclaw-heartbeat-automation/">
  <meta property="og:site_name" content="Kyungwook&#39;s Devlog">
  <meta property="og:title" content="OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법">
  <meta property="og:description" content="OpenClaw를 사용하다 보면 “AI가 좀 더 능동적으로 움직였으면 좋겠다&#34;는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?
바로 이것이 하트비트(Heartbeat) 기능이 해결하는 문제입니다.
하트비트란 무엇인가? 하트비트는 OpenClaw 에이전트가 일정 주기로 받는 “펄스(pulse)“입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 “지금 내가 해야 할 일이 있나?“를 스스로 판단합니다.
기본 하트비트 프롬프트는 다음과 같습니다:
Read HEARTBEAT.md if it exists (workspace context). Follow it strictly. Do not infer or repeat old tasks from prior chats. If nothing needs attention, reply HEARTBEAT_OK. 하트비트 vs Cron: 언제 무엇을 쓸까? OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-23T21:00:00+09:00">
    <meta property="article:modified_time" content="2026-02-23T21:00:00+09:00">
    <meta property="article:tag" content="Openclaw">
    <meta property="article:tag" content="Automation">
    <meta property="article:tag" content="Heartbeat">
    <meta property="article:tag" content="AI Agent">
    <meta property="article:tag" content="생산성">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법">
<meta name="twitter:description" content="OpenClaw를 사용하다 보면 &ldquo;AI가 좀 더 능동적으로 움직였으면 좋겠다&quot;는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?
바로 이것이 하트비트(Heartbeat) 기능이 해결하는 문제입니다.
하트비트란 무엇인가?
하트비트는 OpenClaw 에이전트가 일정 주기로 받는 &ldquo;펄스(pulse)&ldquo;입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 &ldquo;지금 내가 해야 할 일이 있나?&ldquo;를 스스로 판단합니다.
기본 하트비트 프롬프트는 다음과 같습니다:
Read HEARTBEAT.md if it exists (workspace context). 
Follow it strictly. Do not infer or repeat old tasks from prior chats. 
If nothing needs attention, reply HEARTBEAT_OK.
하트비트 vs Cron: 언제 무엇을 쓸까?
OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kwbaek.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법",
      "item": "https://kwbaek.github.io/posts/2026-02-23-openclaw-heartbeat-automation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법",
  "name": "OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법",
  "description": "OpenClaw를 사용하다 보면 \u0026ldquo;AI가 좀 더 능동적으로 움직였으면 좋겠다\u0026quot;는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?\n바로 이것이 하트비트(Heartbeat) 기능이 해결하는 문제입니다.\n하트비트란 무엇인가? 하트비트는 OpenClaw 에이전트가 일정 주기로 받는 \u0026ldquo;펄스(pulse)\u0026ldquo;입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 \u0026ldquo;지금 내가 해야 할 일이 있나?\u0026ldquo;를 스스로 판단합니다.\n기본 하트비트 프롬프트는 다음과 같습니다:\nRead HEARTBEAT.md if it exists (workspace context). Follow it strictly. Do not infer or repeat old tasks from prior chats. If nothing needs attention, reply HEARTBEAT_OK. 하트비트 vs Cron: 언제 무엇을 쓸까? OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?\n",
  "keywords": [
    "OpenClaw", "Automation", "Heartbeat", "AI Agent", "생산성"
  ],
  "articleBody": "OpenClaw를 사용하다 보면 “AI가 좀 더 능동적으로 움직였으면 좋겠다\"는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?\n바로 이것이 하트비트(Heartbeat) 기능이 해결하는 문제입니다.\n하트비트란 무엇인가? 하트비트는 OpenClaw 에이전트가 일정 주기로 받는 “펄스(pulse)“입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 “지금 내가 해야 할 일이 있나?“를 스스로 판단합니다.\n기본 하트비트 프롬프트는 다음과 같습니다:\nRead HEARTBEAT.md if it exists (workspace context). Follow it strictly. Do not infer or repeat old tasks from prior chats. If nothing needs attention, reply HEARTBEAT_OK. 하트비트 vs Cron: 언제 무엇을 쓸까? OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?\n하트비트를 사용할 때: 여러 체크를 묶고 싶을 때 (예: 이메일 + 캘린더 + 알림을 한 번에) 대화 맥락이 필요할 때 (최근 대화 내용을 참고해야 하는 경우) 타이밍이 약간 유동적이어도 괜찮을 때 (~30분마다, 정확한 시각은 중요하지 않음) API 호출을 절약하고 싶을 때 (여러 체크를 배치로 처리) Cron을 사용할 때: 정확한 시각이 중요할 때 (매주 월요일 오전 9시 정각) 작업이 세션 히스토리와 독립적일 때 다른 모델이나 thinking 레벨을 쓰고 싶을 때 일회성 리마인더 (“20분 후에 알려줘”) 출력을 메인 세션 개입 없이 바로 채널로 보내고 싶을 때 팁: 비슷한 주기적 체크들은 HEARTBEAT.md에 배치로 묶어서 처리하세요. Cron은 정확한 스케줄과 독립적 작업을 위해 남겨두세요.\nHEARTBEAT.md 작성 예시 ~/.openclaw/workspace/HEARTBEAT.md 파일을 만들어서 체크리스트를 정의합니다:\n# 하트비트 체크리스트 ## 이메일 확인 (2시간마다) - 미읽은 중요 이메일 있는지 확인 - 회신 필요한 것 있으면 알림 ## 캘린더 (아침/점심/저녁) - 다음 2시간 내 일정 확인 - 30분 전 미리 알림 ## 날씨 (아침 9시) - 오늘 날씨 체크 - 비 예보 있으면 알림 ## 메모리 정리 (매일 자정) - 최근 3일 memory/*.md 검토 - MEMORY.md 업데이트 필요한 내용 반영 하트비트 상태 추적 memory/heartbeat-state.json 파일로 마지막 체크 시각을 추적할 수 있습니다:\n{ \"lastChecks\": { \"email\": 1771550600, \"calendar\": 1771546800, \"weather\": null } } 이렇게 하면 같은 작업을 너무 자주 반복하지 않고, 적절한 간격으로 체크할 수 있습니다.\n언제 조용히 있어야 할까? 하트비트는 능동성과 소음 사이의 균형이 중요합니다. 다음 상황에서는 HEARTBEAT_OK로 조용히 넘어가야 합니다:\n늦은 밤 (23:00-08:00) - 긴급 상황이 아니라면 사용자가 명백히 바쁠 때 마지막 체크 이후 새로운 것이 없을 때 30분 이내에 이미 체크했을 때 하트비트로 할 수 있는 능동적 작업 묻지 않고도 할 수 있는 작업들:\n메모리 정리: 최근 daily notes 검토 후 MEMORY.md 업데이트 프로젝트 상태 확인: git status 등 코드 상태 점검 문서 자동 업데이트: 변경사항 기록 자동 커밋: 자체적으로 만든 변경사항 Git에 커밋 \u0026 푸시 백그라운드 리서치: 관심 키워드 관련 최신 뉴스 수집 실전 예시: 블로그 자동 포스팅 제가 운영하는 AI 트렌드 블로그는 하트비트와 Cron을 조합해 자동화되어 있습니다:\nCron (매일 21:00 정각):\nopenclaw cron add \\ --label \"Daily Blog Post\" \\ --schedule \"0 21 * * *\" \\ --command \"Discord #ai-ml-trends 읽고 블로그 글 2개 작성 + Hugo 빌드 + Git 푸시\" 하트비트 (2-4시간마다):\nDiscord 채널 새 메시지 확인 중요한 뉴스 있으면 즉시 요약해서 알림 트렌드 패턴 분석 후 MEMORY.md에 인사이트 기록 이렇게 하면 정시 작업은 Cron으로 정확하게, 유동적인 모니터링은 하트비트로 유연하게 처리할 수 있습니다.\n주의사항: 토큰 비용 하트비트는 편리하지만 매번 API 호출이 발생합니다. 따라서:\nHEARTBEAT.md는 짧게 유지 - 토큰 사용을 최소화 체크 빈도 조절 - 너무 자주 체크하지 않기 우선순위 설정 - 정말 중요한 것만 자주 체크 마치며 하트비트는 OpenClaw를 수동적 도구에서 능동적 어시스턴트로 변화시키는 핵심 기능입니다.\n“AI가 나를 위해 일한다\"는 느낌을 받고 싶다면, 오늘부터 HEARTBEAT.md를 작성해보세요.\n처음에는 이메일 체크 같은 간단한 작업부터 시작하고, 점차 더 복잡한 자동화를 추가해 나가면 됩니다. AI 에이전트가 진정한 “어시스턴트\"가 되는 순간을 경험하게 될 것입니다.\n관련 문서:\nOpenClaw AGENTS.md 가이드 Hooks 기능 활용하기 ",
  "wordCount" : "563",
  "inLanguage": "en",
  "datePublished": "2026-02-23T21:00:00+09:00",
  "dateModified": "2026-02-23T21:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kwbaek.github.io/posts/2026-02-23-openclaw-heartbeat-automation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kyungwook's Devlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kwbaek.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kwbaek.github.io/" accesskey="h" title="Kyungwook&#39;s Devlog (Alt + H)">Kyungwook&#39;s Devlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kwbaek.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://kwbaek.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://kwbaek.github.io/" title="Kyungwook&#39;s Devlog">
                    <span>Kyungwook&#39;s Devlog</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      OpenClaw 하트비트(Heartbeat) 활용: AI 에이전트를 능동적으로 만드는 법
    </h1>
    <div class="post-meta"><span title='2026-02-23 21:00:00 +0900 KST'>February 23, 2026</span>

</div>
  </header> 
  <div class="post-content"><p>OpenClaw를 사용하다 보면 &ldquo;AI가 좀 더 능동적으로 움직였으면 좋겠다&quot;는 생각을 하게 됩니다. 매번 명령을 내리는 것이 아니라, AI가 스스로 주기적으로 상태를 확인하고 필요한 작업을 수행한다면 얼마나 편할까요?</p>
<p>바로 이것이 <strong>하트비트(Heartbeat)</strong> 기능이 해결하는 문제입니다.</p>
<h2 id="하트비트란-무엇인가">하트비트란 무엇인가?<a hidden class="anchor" aria-hidden="true" href="#하트비트란-무엇인가">#</a></h2>
<p>하트비트는 OpenClaw 에이전트가 일정 주기로 받는 &ldquo;펄스(pulse)&ldquo;입니다. 심장 박동처럼 규칙적으로 발생하며, 에이전트는 이 신호를 받을 때마다 &ldquo;지금 내가 해야 할 일이 있나?&ldquo;를 스스로 판단합니다.</p>
<p>기본 하트비트 프롬프트는 다음과 같습니다:</p>
<pre tabindex="0"><code>Read HEARTBEAT.md if it exists (workspace context). 
Follow it strictly. Do not infer or repeat old tasks from prior chats. 
If nothing needs attention, reply HEARTBEAT_OK.
</code></pre><h2 id="하트비트-vs-cron-언제-무엇을-쓸까">하트비트 vs Cron: 언제 무엇을 쓸까?<a hidden class="anchor" aria-hidden="true" href="#하트비트-vs-cron-언제-무엇을-쓸까">#</a></h2>
<p>OpenClaw에는 Cron도 있는데, 하트비트와 어떻게 다를까요?</p>
<h3 id="하트비트를-사용할-때">하트비트를 사용할 때:<a hidden class="anchor" aria-hidden="true" href="#하트비트를-사용할-때">#</a></h3>
<ul>
<li><strong>여러 체크를 묶고 싶을 때</strong> (예: 이메일 + 캘린더 + 알림을 한 번에)</li>
<li><strong>대화 맥락이 필요할 때</strong> (최근 대화 내용을 참고해야 하는 경우)</li>
<li><strong>타이밍이 약간 유동적이어도 괜찮을 때</strong> (~30분마다, 정확한 시각은 중요하지 않음)</li>
<li><strong>API 호출을 절약하고 싶을 때</strong> (여러 체크를 배치로 처리)</li>
</ul>
<h3 id="cron을-사용할-때">Cron을 사용할 때:<a hidden class="anchor" aria-hidden="true" href="#cron을-사용할-때">#</a></h3>
<ul>
<li><strong>정확한 시각이 중요할 때</strong> (매주 월요일 오전 9시 정각)</li>
<li><strong>작업이 세션 히스토리와 독립적일 때</strong></li>
<li><strong>다른 모델이나 thinking 레벨을 쓰고 싶을 때</strong></li>
<li><strong>일회성 리마인더</strong> (&ldquo;20분 후에 알려줘&rdquo;)</li>
<li><strong>출력을 메인 세션 개입 없이 바로 채널로 보내고 싶을 때</strong></li>
</ul>
<p><strong>팁</strong>: 비슷한 주기적 체크들은 <code>HEARTBEAT.md</code>에 배치로 묶어서 처리하세요. Cron은 정확한 스케줄과 독립적 작업을 위해 남겨두세요.</p>
<h2 id="heartbeatmd-작성-예시">HEARTBEAT.md 작성 예시<a hidden class="anchor" aria-hidden="true" href="#heartbeatmd-작성-예시">#</a></h2>
<p><code>~/.openclaw/workspace/HEARTBEAT.md</code> 파일을 만들어서 체크리스트를 정의합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span># 하트비트 체크리스트
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 이메일 확인 (2시간마다)
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 미읽은 중요 이메일 있는지 확인
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 회신 필요한 것 있으면 알림
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 캘린더 (아침/점심/저녁)
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 다음 2시간 내 일정 확인
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 30분 전 미리 알림
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 날씨 (아침 9시)
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 오늘 날씨 체크
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 비 예보 있으면 알림
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 메모리 정리 (매일 자정)
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> 최근 3일 memory/*.md 검토
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> MEMORY.md 업데이트 필요한 내용 반영
</span></span></code></pre></div><h2 id="하트비트-상태-추적">하트비트 상태 추적<a hidden class="anchor" aria-hidden="true" href="#하트비트-상태-추적">#</a></h2>
<p><code>memory/heartbeat-state.json</code> 파일로 마지막 체크 시각을 추적할 수 있습니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;lastChecks&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;email&#34;</span>: <span style="color:#ae81ff">1771550600</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;calendar&#34;</span>: <span style="color:#ae81ff">1771546800</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;weather&#34;</span>: <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이렇게 하면 같은 작업을 너무 자주 반복하지 않고, 적절한 간격으로 체크할 수 있습니다.</p>
<h2 id="언제-조용히-있어야-할까">언제 조용히 있어야 할까?<a hidden class="anchor" aria-hidden="true" href="#언제-조용히-있어야-할까">#</a></h2>
<p>하트비트는 능동성과 소음 사이의 균형이 중요합니다. 다음 상황에서는 <code>HEARTBEAT_OK</code>로 조용히 넘어가야 합니다:</p>
<ul>
<li><strong>늦은 밤 (23:00-08:00)</strong> - 긴급 상황이 아니라면</li>
<li><strong>사용자가 명백히 바쁠 때</strong></li>
<li><strong>마지막 체크 이후 새로운 것이 없을 때</strong></li>
<li><strong>30분 이내에 이미 체크했을 때</strong></li>
</ul>
<h2 id="하트비트로-할-수-있는-능동적-작업">하트비트로 할 수 있는 능동적 작업<a hidden class="anchor" aria-hidden="true" href="#하트비트로-할-수-있는-능동적-작업">#</a></h2>
<p>묻지 않고도 할 수 있는 작업들:</p>
<ol>
<li><strong>메모리 정리</strong>: 최근 daily notes 검토 후 MEMORY.md 업데이트</li>
<li><strong>프로젝트 상태 확인</strong>: <code>git status</code> 등 코드 상태 점검</li>
<li><strong>문서 자동 업데이트</strong>: 변경사항 기록</li>
<li><strong>자동 커밋</strong>: 자체적으로 만든 변경사항 Git에 커밋 &amp; 푸시</li>
<li><strong>백그라운드 리서치</strong>: 관심 키워드 관련 최신 뉴스 수집</li>
</ol>
<h2 id="실전-예시-블로그-자동-포스팅">실전 예시: 블로그 자동 포스팅<a hidden class="anchor" aria-hidden="true" href="#실전-예시-블로그-자동-포스팅">#</a></h2>
<p>제가 운영하는 AI 트렌드 블로그는 하트비트와 Cron을 조합해 자동화되어 있습니다:</p>
<p><strong>Cron (매일 21:00 정각)</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openclaw cron add <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  --label <span style="color:#e6db74">&#34;Daily Blog Post&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  --schedule <span style="color:#e6db74">&#34;0 21 * * *&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  --command <span style="color:#e6db74">&#34;Discord #ai-ml-trends 읽고 블로그 글 2개 작성 + Hugo 빌드 + Git 푸시&#34;</span>
</span></span></code></pre></div><p><strong>하트비트 (2-4시간마다)</strong>:</p>
<ul>
<li>Discord 채널 새 메시지 확인</li>
<li>중요한 뉴스 있으면 즉시 요약해서 알림</li>
<li>트렌드 패턴 분석 후 MEMORY.md에 인사이트 기록</li>
</ul>
<p>이렇게 하면 정시 작업은 Cron으로 정확하게, 유동적인 모니터링은 하트비트로 유연하게 처리할 수 있습니다.</p>
<h2 id="주의사항-토큰-비용">주의사항: 토큰 비용<a hidden class="anchor" aria-hidden="true" href="#주의사항-토큰-비용">#</a></h2>
<p>하트비트는 편리하지만 매번 API 호출이 발생합니다. 따라서:</p>
<ol>
<li><strong>HEARTBEAT.md는 짧게 유지</strong> - 토큰 사용을 최소화</li>
<li><strong>체크 빈도 조절</strong> - 너무 자주 체크하지 않기</li>
<li><strong>우선순위 설정</strong> - 정말 중요한 것만 자주 체크</li>
</ol>
<h2 id="마치며">마치며<a hidden class="anchor" aria-hidden="true" href="#마치며">#</a></h2>
<p>하트비트는 OpenClaw를 수동적 도구에서 능동적 어시스턴트로 변화시키는 핵심 기능입니다.</p>
<p>&ldquo;AI가 나를 위해 일한다&quot;는 느낌을 받고 싶다면, 오늘부터 <code>HEARTBEAT.md</code>를 작성해보세요.</p>
<p>처음에는 이메일 체크 같은 간단한 작업부터 시작하고, 점차 더 복잡한 자동화를 추가해 나가면 됩니다. AI 에이전트가 진정한 &ldquo;어시스턴트&quot;가 되는 순간을 경험하게 될 것입니다.</p>
<hr>
<p><strong>관련 문서</strong>:</p>
<ul>
<li><a href="https://github.com/OpenClaw/openclaw">OpenClaw AGENTS.md 가이드</a></li>
<li><a href="https://openclaw.com/docs/hooks">Hooks 기능 활용하기</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kwbaek.github.io/tags/openclaw/">Openclaw</a></li>
      <li><a href="https://kwbaek.github.io/tags/automation/">Automation</a></li>
      <li><a href="https://kwbaek.github.io/tags/heartbeat/">Heartbeat</a></li>
      <li><a href="https://kwbaek.github.io/tags/ai-agent/">AI Agent</a></li>
      <li><a href="https://kwbaek.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1/">생산성</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="kwbaek/blog-comments"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kwbaek.github.io/">Kyungwook&#39;s Devlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
