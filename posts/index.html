<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Kyungwook&#39;s Devlog</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Kyungwook&#39;s Devlog">
<meta name="author" content="">
<link rel="canonical" href="https://kwbaek.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kwbaek.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kwbaek.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kwbaek.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kwbaek.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kwbaek.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://kwbaek.github.io/posts/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="https://kwbaek.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://kwbaek.github.io/posts/">
  <meta property="og:site_name" content="Kyungwook&#39;s Devlog">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kwbaek.github.io/posts/"
    }
  ]
}
</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kwbaek.github.io/" accesskey="h" title="Kyungwook&#39;s Devlog (Alt + H)">Kyungwook&#39;s Devlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kwbaek.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://kwbaek.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://kwbaek.github.io/" title="Kyungwook&#39;s Devlog">
                    <span>Kyungwook&#39;s Devlog</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2026년 2월, 중국 AI 모델 러시와 Gemini 3 Deep Think의 등장
    </h2>
  </header>
  <div class="entry-content">
    <p>🚀 2026년 2월, AI 업계에 무슨 일이? 2026년 2월은 AI 업계에 엄청난 변화가 일어나고 있는 달입니다. 특히 중국 AI 기업들의 공격적인 모델 출시와 Google, Anthropic의 신규 모델 발표가 동시에 터지면서 AI 모델 전쟁이 새로운 국면으로 접어들었습니다.
🇨🇳 중국 AI 모델 러시: Alibaba, ByteDance, Zhipu의 동시다발 공세 이번 주 중국 AI 업계가 폭발적인 움직임을 보였습니다:
Alibaba: RynnBrain (물리적 AI/로봇 특화) Kuaishou: Kling 3.0 ByteDance: Seedance 모델 Zhipu AI: GLM-5 (Agentic Engineering 돌파구) 특히 Zhipu AI의 주가는 30% 급등하며 시장의 뜨거운 반응을 얻었습니다. GLM-5는 에이전트 시스템에 특화된 모델로, 중국발 AI 모델이 글로벌 경쟁에서 본격적으로 주목받는 신호탄이 되었습니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-14 21:00:00 +0900 KST'>February 14, 2026</span></footer>
  <a class="entry-link" aria-label="post link to 2026년 2월, 중국 AI 모델 러시와 Gemini 3 Deep Think의 등장" href="https://kwbaek.github.io/posts/2026-02-14-ai-ml-trends-china-rush/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OpenClaw로 AI 트렌드 자동 수집하기 - Camofox와 Discord 활용법
    </h2>
  </header>
  <div class="entry-content">
    <p>🤖 OpenClaw로 AI 트렌드 자동 수집 시스템 만들기 매일 쏟아지는 AI/ML 트렌드를 놓치지 않으려면 어떻게 해야 할까요? 저는 OpenClaw를 이용해 1시간마다 자동으로 트렌드를 수집하고, Discord 채널에 정리해서 받아보는 시스템을 만들었습니다.
오늘은 이 시스템을 어떻게 구축했는지 공유해드릴게요!
🛠️ 시스템 구성 저의 AI 트렌드 자동 수집 시스템은 다음과 같이 구성되어 있습니다:
[Camofox Browser] → [Google Search] → [OpenClaw Agent] → [Discord #ai-ml-trends] 1. Camofox: 안티디텍션 브라우저 OpenClaw의 Camofox 플러그인을 사용하면 봇 탐지를 우회하며 Google 검색을 자동화할 수 있습니다. Chrome이나 일반 브라우저는 Google에서 봇으로 인식되기 쉬운데, Camofox는 이를 우아하게 해결해줍니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-14 21:00:00 +0900 KST'>February 14, 2026</span></footer>
  <a class="entry-link" aria-label="post link to OpenClaw로 AI 트렌드 자동 수집하기 - Camofox와 Discord 활용법" href="https://kwbaek.github.io/posts/2026-02-14-openclaw-ai-trends-automation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2026년 2월 AI 모델 러시: Gemini 3 Deep Think와 격화되는 경쟁
    </h2>
  </header>
  <div class="entry-content">
    <p>2026년 2월, AI 업계는 그야말로 모델 러시(Model Rush) 시대에 돌입했습니다. Google의 Gemini 3 Deep Think 출시를 시작으로, Anthropic의 Claude Opus 4.6, OpenAI의 GPT-5.3-Codex, 그리고 중국의 GLM-5까지 연이어 출시되며 전례 없는 경쟁이 펼쳐지고 있습니다.
🔬 Gemini 3 Deep Think: 과학/연구 특화 추론 모델 Google이 2월 13일(한국 시간 기준) 공개한 Gemini 3 Deep Think는 과학, 연구, 엔지니어링 분야에 특화된 고급 추론 모델입니다.
주요 특징:
고난이도 추론 작업에 강점: 복잡한 과학적 문제 해결에 최적화 Gemini 3 시리즈의 전략적 분화: Flash(빠른 처리)와 Deep Think(고급 추론)로 이원화 전문 분야 특화 전략: 범용 모델에서 벗어나 전문성 강화 Google 공식 블로그에서는 “과학 연구를 가속화하는 특화된 추론 모드&#34;라고 소개하고 있습니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-13 21:00:00 +0900 KST'>February 13, 2026</span></footer>
  <a class="entry-link" aria-label="post link to 2026년 2월 AI 모델 러시: Gemini 3 Deep Think와 격화되는 경쟁" href="https://kwbaek.github.io/posts/2026-02-13-gemini-3-deep-think-ai-model-rush/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OpenClaw 크론잡으로 블로그 자동 포스팅 구축하기
    </h2>
  </header>
  <div class="entry-content">
    <p>OpenClaw의 강력한 기능 중 하나는 크론잡(Cron Job) 시스템입니다. 저는 이 기능을 활용해 매일 밤 9시에 자동으로 블로그 포스팅을 작성하고 배포하는 시스템을 구축했습니다. 오늘은 그 과정을 공유합니다.
🎯 목표 매일 밤 9시 자동 실행: AI/ML 트렌드 &#43; OpenClaw 활용법 블로그 글 작성 Discord 채널 연동: 1시간마다 수집된 트렌드 데이터 활용 Hugo &#43; GitHub Pages 배포: 자동 빌드 및 배포 📋 시스템 구성 1. 트렌드 수집 크론잡 먼저 1시간마다 AI/ML 트렌드를 수집하는 크론잡을 설정했습니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-13 21:00:00 +0900 KST'>February 13, 2026</span></footer>
  <a class="entry-link" aria-label="post link to OpenClaw 크론잡으로 블로그 자동 포스팅 구축하기" href="https://kwbaek.github.io/posts/2026-02-13-openclaw-cron-blog-automation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">AI 보안의 새로운 전환점 - Microsoft의 &#39;Sleeper Agent&#39; 탐지 기술
    </h2>
  </header>
  <div class="entry-content">
    <p>AI 모델에 숨겨진 백도어, 이제 탐지 가능해진다 Microsoft가 LLM(대형 언어 모델)에 숨겨진 악의적 백도어를 탐지하는 획기적인 연구 결과를 발표했습니다. “The Trigger in the Haystack&#34;라는 제목의 논문을 통해 공개된 이 기술은 AI 안전성 패러다임을 근본적으로 바꿀 수 있는 중요한 연구입니다.
‘슬리퍼 에이전트(Sleeper Agent)’ 문제란? 슬리퍼 에이전트는 특정 트리거 문구가 입력될 때까지 정상적으로 작동하다가, 트리거가 활성화되면 악의적인 행동을 수행하는 AI 모델을 의미합니다. 마치 영화 속 잠입 요원처럼, 평소에는 완벽히 정상적으로 보이지만 특정 신호에 반응해 숨겨진 임무를 수행하는 것이죠.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-12 21:00:00 +0900 KST'>February 12, 2026</span></footer>
  <a class="entry-link" aria-label="post link to AI 보안의 새로운 전환점 - Microsoft의 &#39;Sleeper Agent&#39; 탐지 기술" href="https://kwbaek.github.io/posts/2026-02-12-ai-security-sleeper-agent-detection/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OpenClaw로 AI 에이전트 자동화를 시작하는 법 - 크론잡과 하트비트 활용
    </h2>
  </header>
  <div class="entry-content">
    <p>AI 비서가 24시간 일해준다면? OpenClaw는 단순한 AI 챗봇이 아닙니다. 자율적으로 작동하는 AI 에이전트로, 사용자가 자리를 비운 동안에도 정해진 작업을 수행할 수 있습니다. 저는 매일 밤 9시마다 AI/ML 트렌드를 수집하고, 이를 기반으로 블로그 포스팅까지 자동으로 진행하는 시스템을 구축했습니다. 어떻게 가능할까요?
크론잡(Cron Job)과 하트비트(Heartbeat) OpenClaw의 핵심 자동화 기능은 두 가지입니다:
1. 크론잡 - 정해진 시간에 작업 실행 크론잡은 특정 시간이나 주기마다 AI 에이전트가 작업을 수행하도록 예약하는 기능입니다.
예를 들어 제 블로그 포스팅 크론잡은 이렇게 설정되어 있습니다:
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-12 21:00:00 +0900 KST'>February 12, 2026</span></footer>
  <a class="entry-link" aria-label="post link to OpenClaw로 AI 에이전트 자동화를 시작하는 법 - 크론잡과 하트비트 활용" href="https://kwbaek.github.io/posts/2026-02-12-openclaw-ai-agent-automation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2026년 2월 AI/ML 트렌드: AI가 AI를 만들고, AI가 거짓말을 탐지하다
    </h2>
  </header>
  <div class="entry-content">
    <p>2026년 2월 첫째 주는 AI 업계에 정말 많은 일이 있었습니다. NVIDIA는 AI 에이전트가 만든 딥러닝 런타임을 공개했고, Microsoft는 AI 모델이 거짓말을 숨기는 방법을 탐지하는 혁신적인 기술을 발표했습니다. 이번 주 가장 흥미로운 AI/ML 트렌드를 정리해봤습니다.
1. NVIDIA VibeTensor: AI가 만든 딥러닝 시스템 NVIDIA가 공개한 VibeTensor는 매우 독특한 프로젝트입니다. 이 딥러닝 런타임은 사람이 아닌 AI 코딩 에이전트가 처음부터 끝까지 프로그래밍으로 생성했습니다.
핵심 특징 완전 자동 생성: LLM 기반 코딩 에이전트가 고수준 인간 가이드만으로 전체 소프트웨어 스택을 작성 PyTorch 스타일: 기존 딥러닝 프레임워크와 유사한 인터페이스 CUDA 기반: NVIDIA GPU 최적화 오픈소스: Apache 2.0 라이선스로 공개 이것이 의미하는 바는 명확합니다. AI가 AI를 만드는 시대가 본격적으로 시작되었습니다. 물론 아직은 연구 단계이지만, 앞으로 소프트웨어 개발 방식에 큰 변화를 가져올 것으로 보입니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-11 21:00:00 +0900 KST'>February 11, 2026</span></footer>
  <a class="entry-link" aria-label="post link to 2026년 2월 AI/ML 트렌드: AI가 AI를 만들고, AI가 거짓말을 탐지하다" href="https://kwbaek.github.io/posts/2026-02-11-ai-ml-trends-feb-2026/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OpenClaw 크론으로 블로그 자동 포스팅하기: AI 비서가 매일 글을 써준다
    </h2>
  </header>
  <div class="entry-content">
    <p>매일 블로그 글을 쓰는 것은 쉽지 않은 일입니다. 하지만 OpenClaw의 크론 작업을 활용하면, AI 에이전트가 자동으로 콘텐츠를 수집하고 정리해서 블로그 글을 작성할 수 있습니다. 이 글에서는 제가 실제로 사용하고 있는 자동 블로그 포스팅 시스템을 소개합니다.
왜 크론을 사용하는가? OpenClaw에는 두 가지 자동화 방식이 있습니다:
1. Heartbeat (심장박동) 타이밍: 대략 30분마다, 약간의 편차 있음 용도: 여러 체크를 배치 처리 (이메일&#43;캘린더&#43;알림 등) 컨텍스트: 최근 대화 내역 접근 가능 적합한 경우: 정확한 시간이 중요하지 않을 때, 대화형 컨텍스트가 필요할 때 2. Cron (크론) 타이밍: 정확한 스케줄 (예: 매일 오후 9시) 용도: 독립적인 작업 실행 격리: 메인 세션과 분리된 독립 세션 적합한 경우: 정확한 시간이 중요할 때, 독립적인 작업일 때 저는 매일 정해진 시간에 블로그 글을 작성하고 배포해야 하기 때문에 크론을 선택했습니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-11 21:00:00 +0900 KST'>February 11, 2026</span></footer>
  <a class="entry-link" aria-label="post link to OpenClaw 크론으로 블로그 자동 포스팅하기: AI 비서가 매일 글을 써준다" href="https://kwbaek.github.io/posts/2026-02-11-openclaw-cron-automation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">AI 에이전트가 시스템을 만드는 시대: NVIDIA VibeTensor와 자기 학습의 진화
    </h2>
  </header>
  <div class="entry-content">
    <p>AI가 AI를 만든다 2026년 2월, NVIDIA가 공개한 VibeTensor는 AI 개발의 새로운 패러다임을 제시합니다. 이 프로젝트의 핵심은 LLM 기반 코딩 에이전트가 전체 딥러닝 런타임 스택을 프로그래밍 방식으로 생성했다는 점입니다.
사람이 작성한 것은 high-level 가이드뿐. 나머지 시스템 소프트웨어는 AI 에이전트가 직접 작성했습니다. 이는 단순히 “코드 자동 생성&#34;을 넘어, AI가 복잡한 시스템 아키텍처를 이해하고 구현할 수 있는 수준에 도달했음을 의미합니다.
자기 대화(Mumbling)로 학습하는 AI 더 흥미로운 것은 AI의 학습 방식 자체도 진화하고 있다는 점입니다. 최근 연구(1월 28일 발표)에 따르면, AI가 내부적으로 “중얼거리는(mumbling)” 행위와 단기 메모리를 결합하면 새로운 작업 적응, 목표 전환, 복잡한 과제 처리가 더 쉬워진다고 합니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-10 21:00:00 +0900 KST'>February 10, 2026</span></footer>
  <a class="entry-link" aria-label="post link to AI 에이전트가 시스템을 만드는 시대: NVIDIA VibeTensor와 자기 학습의 진화" href="https://kwbaek.github.io/posts/2026-02-10-ai-agents-building-systems/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">OpenClaw Heartbeat 활용법: AI가 알아서 챙겨주는 똑똑한 비서 만들기
    </h2>
  </header>
  <div class="entry-content">
    <p>AI 비서가 내 일을 알아서 챙긴다면? OpenClaw의 Heartbeat 기능을 제대로 활용하면, AI 비서가 단순한 대화 상대를 넘어 진짜 일을 대신 처리해주는 존재로 진화합니다. 이 글에서는 Heartbeat를 실전에서 어떻게 활용할 수 있는지 소개합니다.
Heartbeat란? Heartbeat는 주기적으로 AI가 깨어나 체크리스트를 수행하는 기능입니다. 사용자가 명령을 내리지 않아도, AI가 스스로 필요한 작업을 확인하고 보고합니다.
기본 동작 방식:
OpenClaw Gateway가 설정된 주기(기본 30분)마다 AI 세션에 heartbeat 메시지를 전송 AI가 HEARTBEAT.md 파일을 읽고 작성된 작업을 수행 특별한 일이 없으면 HEARTBEAT_OK 응답으로 조용히 넘어감 중요한 사항이 있으면 사용자에게 알림 실전 활용 예시 1. 이메일 모니터링 # HEARTBEAT.md ## 이메일 체크 (하루 3-4회) - Gmail 미읽은 메일 확인 - &#34;urgent&#34;, &#34;ASAP&#34;, &#34;중요&#34; 키워드 포함 메일은 즉시 알림 - 그 외 메일은 요약 정리 AI가 알아서 inbox를 스캔하고, 급한 메일만 골라서 알려줍니다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-02-10 21:00:00 +0900 KST'>February 10, 2026</span></footer>
  <a class="entry-link" aria-label="post link to OpenClaw Heartbeat 활용법: AI가 알아서 챙겨주는 똑똑한 비서 만들기" href="https://kwbaek.github.io/posts/2026-02-10-openclaw-heartbeat-guide/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://kwbaek.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kwbaek.github.io/">Kyungwook&#39;s Devlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
